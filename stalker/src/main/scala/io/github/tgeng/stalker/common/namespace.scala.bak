package io.github.tgeng.stalker.core.tt

import scala.collection.Set
import scala.collection.mutable
import io.github.tgeng.stalker.common.QualifiedName
import io.github.tgeng.stalker.core.common._
import io.github.tgeng.common.extraSeqOps
import QualifiedName._
import Error._

// extension nsElemSetOps on (elems: Set[NsElem]) {
//   def % (names: Seq[String]) : Set[NsElem] = elems.filterImpl(names.toList)
//   def filterImpl(names: List[String]) : Set[NsElem] = names match {
//     case Nil => elems
//     case name :: rest => elems.namespaces.flatMap(_.elems.filter(_.name == name)).filterImpl(rest)
//   }
//   def constructors : Set[String] = elems.collect{ case NConstructor(name) => name }
//   def qualifiedNames : Set[QualifiedName] = elems.collect { case NQualifiedName(qn) => qn }
//   def namespaces: Set[Namespace] = elems.collect{ case NNamespace(ns) => ns }

//   def resolveQualifiedName(names: Seq[String]) : Result[QualifiedName] = (elems % names).qualifiedNames.toList match {
//     case Nil => noNameError(e"$names does not reference a valid definition.")
//     case qn :: Nil => Right(qn)
//     case qns => ambiguousNameError(e"$names references multiple different definitions $qns.")
//   }
  
//   def resolveConstructor(names: Seq[String]) : Result[String] = (elems % names).constructors.toList match {
//     case Nil => noNameError(e"$names does not reference a valid constructor.")
//     case n :: Nil => Right(n)
//     case names => ambiguousNameError(e"$names references multiple distinct constructor names $names.")
//   }
// }

// class MutableNamespace extends Namespace {
//   import QualifiedName.{_, given _}
//   import scala.collection.mutable.Map
//   import scala.collection.mutable.Set
 
//   private val content = Map[String, mutable.Set[NsElem]]().withDefault{ _ => mutable.Set() }
//   export content.iterator

//   def getElems(name: String) : mutable.Set[NsElem] = content(name)
// }

// object MutableNamespace {
//   import scala.language.implicitConversions
//   import PreDeclaration._
//   import builtins._

//   def createWithBuiltins(qn: QualifiedName) : MutableNamespace = {
//     val r = InMemoryNamespace(qn)
//     r.importNs(levelType)
//     r.importNs(typeType)
//     r.importNs(lsucFn)
//     r.importNs(lmaxFn)
//     r.importNs(idTypeNs)
//     r.merge(idTypeNs)
//     r
//   }
//   def create(qn: QualifiedName) : MutableNamespace = InMemoryNamespace(qn)

//   given dataToNamespace as Conversion[PreData, Namespace] = d => {
//     val r = InMemoryNamespace(d.qn)
//     val cons = d.cons
//     for (con <- cons) {
//       r(con.name) = LeafNamespace(d.qn / con.name, Some(con.name))
//     }
//     r
//   }

//   given recordToNamespace as Conversion[PreRecord, Namespace] = r => LeafNamespace(r.qn)
//   given definitionToNamespace as Conversion[PreDefinition, Namespace] = d => LeafNamespace(d.qn)

//   val idTypeNs : Namespace = {
//     val r = InMemoryNamespace(idType.qn)
//     r("Refl") = LeafNamespace(idType.qn / "Refl", Some("Refl"))
//     r
//   }
// }

// case class EmptyNamespace(override val qn: QualifiedName, override val constructorName: Option[String] = None) extends Namespace {
//   override def get(name: String) = noNameError(e"Cannot find $name in $qn.")

//   override def iterator: Iterator[(String, Namespace)] = Iterator.empty
// }

// object EmptyNamespace {
//   val root: EmptyNamespace = EmptyNamespace(Root, None)
// }

// trait MutableNamespace extends Namespace {
//   def importNs(ns: Namespace) : Unit = ns.qn match {
//     case Root => merge(ns)
//     case parent / name => this(name) = ns
//   }

//   def merge(ns: Namespace) : Unit = {
//     ns.foreach(this.update)
//   }
  
//   def addDeclaration(name: String, constructors: String*) : Unit = addDeclaration(name, constructors)

//   def addDeclaration(name: String, constructors: Iterable[String]) : Unit = { 
//     if (constructors.isEmpty) this(name) = LeafNamespace(qn / name, None)
//     else {
//       val ns = InMemoryNamespace(qn / name)
//       for (child <- constructors) {
//         ns(child) = LeafNamespace(ns.qn / child, Some(child))
//       }
//       this(name) = ns
//     }
//   }

//   def update(name: String, ns: Namespace) : Unit
// }
